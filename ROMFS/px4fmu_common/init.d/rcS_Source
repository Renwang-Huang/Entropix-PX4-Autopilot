#!/bin/sh

#------------------------------------------------------------------------------
# 环境变量的引用规则：
#    如果写成 ${VAR}，变量名在 } 结束
#    如果写成 $VAR，变量名会一直延续到参数的末尾（可能跟后面字符粘连，容易出错）
#
# 环境变量的使用案例：
#    FOO=123
#    echo ${FOO}abc   # 输出 123abc
#    echo $FOOabc     # Shell 会尝试找名为 FOOabc 的变量，可能为空
#
# 在写入 ROMFS 时注释行会被去掉，不会占用飞控的存储空间
#------------------------------------------------------------------------------

#  +e忽略错误继续执行， -e遇到错误就退出
set +e

# 下面这条指令会使每一条执行的命令都打印出来，方便调试
# set -x

# 设置默认参数，不要加多余的空格否则可能会占用额外的闪存空间
set R /
set FCONFIG /fs/microsd/etc/config.txt
set FEXTRAS /fs/microsd/etc/extras.txt
set FRC /fs/microsd/etc/rc.txt
set IOFW "/etc/extras/px4_io-v2_default.bin"
set LOGGER_ARGS ""
set LOGGER_BUF 8
set PARAM_FILE ""
set PARAM_BACKUP_FILE ""
set RC_INPUT_ARGS ""
set STORAGE_AVAILABLE no
set SDCARD_EXT_PATH /fs/microsd/ext_autostart
set SDCARD_FORMAT no
set STARTUP_TUNE 1
set VEHICLE_TYPE none

# 设置为1表示升级固件但是维持原先参数，设置为2表示升级固件后用新固件的默认参数覆盖原先的参数
set PARAM_DEFAULTS_VER 1

# 打印完整的（而不是简单的）系统版本信息
ver all   # ver是PX4 NuttShell(NSH)提供的一个内置命令

# 挂载microSD卡
if [ -b "/dev/mmcsd0" ]   # 测试 /dev/mmcsd0 是否存在且为块设备（block device）
then
	if mount -t vfat /dev/mmcsd0 /fs/microsd   # 尝试以 VFAT（FAT 文件系统）类型把设备挂到 /fs/microsd
	then
		if [ -f "/fs/microsd/.format" ]   # 如果挂载成功，检查挂载点下是否存在 .format 文件（一个触发“强制格式化”的标记文件）
		then
			echo "INFO [init] format /dev/mmcsd0 requested (/fs/microsd/.format)"
			set SDCARD_FORMAT yes
			rm /fs/microsd/.format
			umount /fs/microsd   # 格式化前必须卸载设备

		else
			set STORAGE_AVAILABLE yes   # 如果没有 .format说明 SD 卡正常且不需要格式化，存储可用
		fi
	fi

	# 启动格式化流程
	if [ $STORAGE_AVAILABLE = no -o $SDCARD_FORMAT = yes ]
	then
		echo "INFO [init] formatting /dev/mmcsd0"
		set STARTUP_TUNE 15 # STARTUP_TUNE 设为15表示 SD_ERROR 提示音/信号，如果后面格式化并挂载成功，会改为 14（SD_INIT）

		if mkfatfs -F 32 /dev/mmcsd0   # 尝试把设备格式化为 FAT32（-F 32）
		then
			echo "INFO [init] card formatted"

			if mount -t vfat /dev/mmcsd0 /fs/microsd
			then
				set STORAGE_AVAILABLE yes
				set STARTUP_TUNE 14
			else
				echo "ERROR [init] card mount failed"
			fi
		else
			echo "ERROR [init] format failed"
		fi
	fi
else
	# 如果 /dev/mmcsd0 不存在，脚本执行 mft query -q -k MTD -s MTD_PARAMETERS -v /mnt/microsd 去查询
	# 是否有其它类型（例如 MTD/闪存分区）被挂载到 /mnt/microsd，如果是则设 STORAGE_AVAILABLE=yes
	if mft query -q -k MTD -s MTD_PARAMETERS -v /mnt/microsd
	then
		set STORAGE_AVAILABLE yes
	fi
fi

if [ $STORAGE_AVAILABLE = yes ]
then
	if hardfault_log check   # 飞控如果曾经崩溃过（有崩溃日志留存），在开机时把错误记录下来，并提示用户
	then
		set STARTUP_TUNE 2 # tune 2 = ERROR_TUNE
		if hardfault_log commit
		then
			hardfault_log reset
		fi
	fi

	# ext_autostart_new 文件夹存在 → 表示用户（或系统）准备更新飞控的外部启动脚本
	if [ -e /fs/microsd/ext_autostart_new ]
	then
		echo "Updating external autostart files"
		rm -r $SDCARD_EXT_PATH
		mv /fs/microsd/ext_autostart_new $SDCARD_EXT_PATH
	fi

	set PARAM_FILE /fs/microsd/params
	set PARAM_BACKUP_FILE "/fs/microsd/parameters_backup.bson"
fi

if [ -f $FRC ]   # 默认有set FRC /fs/microsd/etc/rc.txt
then
	. $FRC
else
	# 加载参数文件路径配置
	. ${R}etc/init.d/rc.filepaths

	# 检查 /fs/mtd_caldata 这个文件是不是一个有效的BSON文件（PX4用BSON存储参数）
	if ! bsondump docsize /fs/mtd_caldata
	then
		echo "New /fs/mtd_caldata size is:"
		bsondump docsize /fs/mtd_caldata
	fi

	# 加载/fs/mtd_caldata，飞控启动时就会带着正确的传感器校准值
	if mft query -q -k MTD -s MTD_CALDATA -v /fs/mtd_caldata
	then
		param load /fs/mtd_caldata
	fi

	param select $PARAM_FILE
	if ! param import
	then
		echo "ERROR [init] param import failed"
		set STARTUP_TUNE 2 # tune 2 = ERROR_TUNE

		bsondump $PARAM_FILE   # 检查 $PARAM_FILE 的 BSON 格式内容（帮助诊断问题）

		if [ -d "/fs/microsd" ]
		then
			cp $PARAM_FILE /fs/microsd/param_import_fail.bson   # 把出错的参数文件保存到 SD 卡，命名为 param_import_fail.bson，以便事后分析

			# 导入备份参数
			if [ -f $PARAM_BACKUP_FILE ]
			then
				echo "[init] importing from parameter backup"

				# 大概率是文件损坏，所以把备份文件和出错文件进行对比（对应bsondump $PARAM_FILE）
				bsondump $PARAM_BACKUP_FILE

				param import $PARAM_BACKUP_FILE

				cp $PARAM_BACKUP_FILE $PARAM_FILE
			fi

			param status   # 打印参数系统的状态，确认恢复结果

			dmesg >> /fs/microsd/param_import_fail.txt &   # 把系统日志（内核消息dmesg）输出到有关文件用于调试
		fi
	fi

	if [ $STORAGE_AVAILABLE = yes ]
	then
		param select-backup $PARAM_BACKUP_FILE
	fi

	# 检查飞控板硬件配置是否支持以太网
	if mft query -q -k MFT -s MFT_ETHERNET -v 1
	then
		netman update -i eth0
	fi

	# 如果启动前参数 SYS_AUTOCONFIG 大于0，那么启动时会触发一次参数重置
	if param greater SYS_AUTOCONFIG 0
	then
	        # 除了部分参数之外其余参数均被重置
		param reset_all SYS_AUTOSTART SYS_PARAM_VER RC* CAL_* COM_FLTMODE* LND_FLIGHT* TC_* COM_FLIGHT*
	fi

	# 板级架构默认配置
	set BOARD_ARCH_RC_DEFAULTS ${R}etc/init.d/rc.board_arch_defaults
	if [ -f $BOARD_ARCH_RC_DEFAULTS ]
	then
		echo "Board architecture defaults: ${BOARD_ARCH_RC_DEFAULTS}"
		. $BOARD_ARCH_RC_DEFAULTS
	fi
	unset BOARD_ARCH_RC_DEFAULTS

	# 具体板子的默认配置
	set BOARD_RC_DEFAULTS ${R}etc/init.d/rc.board_defaults
	if [ -f $BOARD_RC_DEFAULTS ]
	then
		echo "Board defaults: ${BOARD_RC_DEFAULTS}"
		. $BOARD_RC_DEFAULTS
	fi
	unset BOARD_RC_DEFAULTS

	# 可选的额外初始化文件
	set BOARD_RC_ADDITIONAL_INIT ${R}etc/init.d/rc.additional_init
	if [ -f $BOARD_RC_ADDITIONAL_INIT ]
	then
		echo "Board additional init: ${BOARD_RC_ADDITIONAL_INIT}"
		. $BOARD_RC_ADDITIONAL_INIT
	fi
	unset BOARD_RC_ADDITIONAL_INIT

	# PX4 根据 SYS_AUTOSTART 参数选择并加载机型配置
	if ! param compare SYS_AUTOSTART 0
	then
		# rc.autostart 直接运行正确的 airframe 脚本
		. ${R}etc/init.d/rc.autostart

		if [ ${VEHICLE_TYPE} = none ]
		then
			if [ $STORAGE_AVAILABLE = yes ]
			then
				. ${R}etc/init.d/rc.autostart_ext
			else
				echo "ERROR [init] SD card not mounted - can't load external airframe"
			fi
		fi

		if [ ${VEHICLE_TYPE} = none ]
		then
			echo "ERROR [init] No airframe file found for SYS_AUTOSTART value"
			param set SYS_AUTOSTART 0
			tune_control play error
		fi
	fi

	if ! param compare SYS_PARAM_VER ${PARAM_DEFAULTS_VER}
	then
		echo "Switched to different parameter version. Resetting parameters."
		param set SYS_PARAM_VER ${PARAM_DEFAULTS_VER}
		param set SYS_AUTOCONFIG 1
		param save
		reboot
	fi

	# 让飞控板可以发出蜂鸣器提示音
	tone_alarm start

	# 管理飞行任务数据、航点和持久化存储
	if param compare -s SYS_DM_BACKEND 1
	then
		dataman start -r
	else
		if param compare SYS_DM_BACKEND 0
		then
			dataman start
		fi
	fi

	# 启动 PX4 的事件发送（socket 通信）处理模块
	send_event start

	# 启动 PX4 的硬件故障（hardfault）数据流模块
	if param compare -s SYS_HF_MAV 1
	then
		hardfault_stream start
	fi

	# 用于监控飞控系统的 CPU、内存、任务调度等负载情况
	load_mon start

	# 启动 PX4 的系统状态指示灯（RGB LED）驱动
	rgbled start -X -q
	rgbled_ncp5623c start -X -q
	rgbled_lp5562 start -X -q
	rgbled_is31fl3195 start -X -q

	# 加载用户自定义参数配置文件
	if [ -f $FCONFIG ]
	then
		echo "Custom: ${FCONFIG}"
		. $FCONFIG
	fi

	# PX4 启动飞控传感器系统（Sensors System）的逻辑
	if param greater SYS_HITL 0
	then
		sensors start -h

		param set GPS_1_CONFIG 0

		if param compare SYS_HITL 2   # 启动全套硬件模拟器
		then
			simulator_sih start
			sensor_baro_sim start
			sensor_mag_sim start
			sensor_gps_sim start
			sensor_agp_sim start
		fi

	else   # 不启用仿真的硬件启动逻辑
		set BOARD_RC_SENSORS ${R}etc/init.d/rc.board_sensors
		if [ -f $BOARD_RC_SENSORS ]
		then
			echo "Board sensors: ${BOARD_RC_SENSORS}"
			. $BOARD_RC_SENSORS
		fi
		unset BOARD_RC_SENSORS

		. ${R}etc/init.d/rc.sensors

		if param compare -s BAT1_SOURCE 2
		then
			esc_battery start
		fi

		if ! param compare BAT1_SOURCE 1
		then
			battery_status start
		fi

		sensors start
	fi

	# 选择状态估计器
	if param compare -s EKF2_EN 1
	then
		ekf2 start &   # 后台启动从而不影响其他模块，融合多源传感器数据
	fi

	# LPE用于仅依赖IMU和传感器的局部位置估计，通常用于GPS丢失或室内环境
	if param compare -s LPE_EN 1
	then
		local_position_estimator start
	fi

	# 姿态估计器仅计算飞行器姿态但是不估计位置
	if param compare -s ATT_EN 1
	then
		attitude_estimator_q start
	fi

	# PX4 启动PX4IO模块并检查/更新固件
	if px4io supported
	then
		if [ -f $IOFW ]
		then
			if ! px4io checkcrc ${IOFW}   # 使用checkcrc检查PX4IO当前固件与$IOFW文件CRC是否一致
			then
				tune_control play -t 16   # 播放提示音16，表示开始升级PX4IO固件

				if px4io update ${IOFW}
				then
					usleep 10000
					tune_control stop   # 升级成功后等待10 ms并停止提示音
					if px4io checkcrc ${IOFW}
					then
						tune_control play -t 17 # tune 17 = PROG_PX4IO_OK
					else
						tune_control play -t 18 # tune 18 = PROG_PX4IO_ERR
					fi
				else
					tune_control stop
				fi
			fi

			if ! px4io start
			then
				echo "PX4IO start failed"
				set STARTUP_TUNE 2 # tune 2 = ERROR_TUNE
			fi
		fi
	fi

	# 启动温控 IMU 的加热器驱动（Heater Driver）
	if param compare -s SENS_EN_THERMAL 1
	then
		heater start
	fi

	# 启动 PX4 的遥控器（RC）信号处理和手动控制模块
	rc_update start
	manual_control start

	# 启动 PX4 的相机触发与反馈模块
	if param greater -s TRIG_MODE 0
	then
		camera_trigger start
		camera_feedback start
	fi
	# 启动 PPS（Pulse Per Second）捕获模块，用于接收精确时间同步信号（通常来自 GPS 或外部同步源）
	if param greater -s PPS_CAP_ENABLE 0
	then
		pps_capture start
	fi
	# 启动 RPM 捕获模块，读取电机转速传感器信号，用于监控或控制电机性能
	if param greater -s RPM_CAP_ENABLE 0
	then
		rpm_capture start
	fi
	# 启动相机捕获反馈模块，用于接收相机拍照完成信号或同步反馈
	if param greater -s CAM_CAP_FBACK 0
	then
		if camera_capture start
		then
			camera_capture on
		fi
	fi

	# 启动 Commander 模块，它是 PX4 的核心任务管理器
	if param greater SYS_HITL 0
	then
		commander start -h

		if ! pwm_out_sim start -m hil
		then
			tune_control play error
		fi

	else
		commander start

		dshot start
		pwm_out start
	fi

	# 这里加载飞行器类型特定的参数
	. ${R}etc/init.d/rc.vehicle_setup

	# 启动起飞前连续磁力计校准（Magnetometer Bias Estimator, MBE）
	if param compare -s MBE_ENABLE 1
	then
		mag_bias_estimator start
	fi

	# 处理板卡特定的 MAVLink 流配置
	set BOARD_RC_MAVLINK ${R}etc/init.d/rc.board_mavlink
	if [ -f $BOARD_RC_MAVLINK ]
	then
		echo "Board mavlink: ${BOARD_RC_MAVLINK}"
		. $BOARD_RC_MAVLINK
	fi
	unset BOARD_RC_MAVLINK

	# 启动UART串口用于连接GPS、遥控器、Telemetry 模块、外部传感器等设备
	. ${R}etc/init.d/rc.serial

	# 启动RC（遥控器）输入模块
	rc_input start $RC_INPUT_ARGS

	# 启动USB接口和MAVLink通信
	if param greater -s SYS_USB_AUTO -1
	then
		if ! cdcacm_autostart start
		then
			sercon
			echo "Starting MAVLink on /dev/ttyACM0"
			mavlink start -d /dev/ttyACM0
		fi
	fi

	# 播放启动提示音（Startup Tune）
	param compare CBRK_BUZZER 782090
	if [ "$?" != "0" -o "$STARTUP_TUNE" != "1" ]
	then
		tune_control play -t $STARTUP_TUNE
	fi

	# 启动导航模块（Navigator）
	navigator start

	# 启动热校准（Thermal Calibration）
	set RC_THERMAL_CAL ${R}etc/init.d/rc.thermal_cal
	if [ -f ${RC_THERMAL_CAL} ]
	then
		. ${RC_THERMAL_CAL}
	fi
	unset RC_THERMAL_CAL

	# 启动云台控制（Gimbal）模块
	if param greater -s MNT_MODE_IN -1
	then
		gimbal start
	fi

	# 启动额外的 telemetry 与 IMU 校准功能
	if param compare -s TEL_BST_EN 1
	then
		bst start -X
	fi

	if param compare -s IMU_GYRO_FFT_EN 1
	then
		gyro_fft start
	fi

	if param compare -s IMU_GYRO_CAL_EN 1
	then
		gyro_calibration start
	fi

	# 启动光流等特定传感器和外设控制模块
	if param compare -s SENS_EN_PX4FLOW 1
	then
		px4flow start -X &
	fi

	payload_deliverer start

	if param compare -s ICE_EN 1
	then
		internal_combustion_engine_control start
	fi

	# 加载板卡提供的可选额外功能模块
	set BOARD_RC_EXTRAS ${R}etc/init.d/rc.board_extras
	if [ -f $BOARD_RC_EXTRAS ]
	then
		echo "Board extras: ${BOARD_RC_EXTRAS}"
		. $BOARD_RC_EXTRAS
	fi
	unset BOARD_RC_EXTRAS

	# 从SD卡启动自定义扩展功能（Addons）
	if [ -f $FEXTRAS ]
	then
		echo "Addons script: ${FEXTRAS}"
		. $FEXTRAS
	fi

	# 启动日志记录模块（Logger）
	set RC_LOGGING ${R}etc/init.d/rc.logging
	if [ -f ${RC_LOGGING} ]
	then
		. ${RC_LOGGING}
	fi
	unset RC_LOGGING

	# 在选定的 SYS_AUTOSTART 启动后，设置额外参数和环境变量
	if ! param compare SYS_AUTOSTART 0
	then
		. ${R}etc/init.d/rc.autostart.post
	fi

	# 检查并执行板卡 Bootloader 升级脚本
	set BOARD_BOOTLOADER_UPGRADE ${R}etc/init.d/rc.board_bootloader_upgrade
	if [ -f $BOARD_BOOTLOADER_UPGRADE ]
	then
		sh $BOARD_BOOTLOADER_UPGRADE
	fi
	unset BOARD_BOOTLOADER_UPGRADE

	# 启动 UAVCAN/Cyphal/ZENOH 通信总线和模块
	if param greater -s UAVCAN_ENABLE 0
	then
		# Start core UAVCAN module.
		if ! uavcan start
		then
			tune_control play error
		fi
	else
		if param greater -s CYPHAL_ENABLE 0
		then
			cyphal start
		fi
	fi
	if param greater -s ZENOH_ENABLE 0
	then
		zenoh start
	fi
fi

# 释放资源
unset R
unset FCONFIG
unset FEXTRAS
unset FRC
unset IOFW
unset LOGGER_ARGS
unset LOGGER_BUF
unset PARAM_FILE
unset PARAM_BACKUP_FILE
unset PARAM_DEFAULTS_VER
unset RC_INPUT_ARGS
unset STORAGE_AVAILABLE
unset SDCARD_EXT_PATH
unset SDCARD_FORMAT
unset STARTUP_TUNE
unset VEHICLE_TYPE

# 标识启动已经执行完毕
mavlink boot_complete
